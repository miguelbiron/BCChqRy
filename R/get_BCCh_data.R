#' Fetch data using an .iqy file from the BCCh
#'
#' \code{get_bcch_data} parses an .iqy file generated by the Statistical Database
#'     of the Central Bank of Chile (BCCh), gets the required data from their server,
#'     and returns it as a data frame.
#'
#' @param path_to_iqy the path to the .iqy file. Can be relative to wd.
#' @param q_values a character vector (or something that can be coerced to it).
#'     Should contain the values for every parameter in the query, in adequate
#'     order. Use only if you already know the query and its parameters. If left
#'     \code{NULL}, the program will ask the user to input these values.
#' @return a data frame with attribute \code{data_types}, which is a character
#'     vector that shows the kind of data stored in each column.
#' @seealso Vist the BCCh database at \url{https://si3.bcentral.cl/Siete/secure/cuadros/home.aspx}.
#'
#' @examples
#'
#' \dontrun{
#' # this should ask the user for a start and an end date
#' get_bcch_data("UF_IVP_DIARIO.iqy")
#' }
#'
#' @export
get_bcch_data = function(path_to_iqy, q_values = NULL){
  iqy_content = readLines(path_to_iqy, warn = FALSE)
  api_url = iqy_content[1]
  query_params = strsplit(iqy_content[2], "&")[[1]]
  query_code = query_params[length(query_params)]
  query_params = query_params[-length(query_params)]
  query_par_mat = stringr::str_match(query_params,
                                     "^([^=]+)=\\[\"(\\w+)\",\"([\\w\\s]+)\"\\]$")[,-1]
  colnames(query_par_mat) = c("param_name", "param_name_2", "param_prompt")

  if(is.null(q_values)){
    # read user input
    q_values = character(nrow(query_par_mat))
    for(i in seq_along(q_values)){
      cat(paste0(query_par_mat[i, "param_prompt"], ": "))
      q_values[i] = readLines(n=1L)
      cat("\n")
    }
  }

  query_par_mat = cbind(query_par_mat, q_values)

  # construct query
  query_url = paste0(api_url,
                     "?",
                     paste(
                       query_par_mat[, "param_name"],
                       query_par_mat[, "q_values"],
                       sep = "=",
                       collapse = "&"
                     ),
                     "&",
                     query_code
  )

  # get vector of data cells from html
  results_cells = rvest::html_text(
    rvest::html_nodes(
      x     = xml2::read_html(query_url),
      xpath = "//td[not(@colspan) and not(table)]"
    )
  )

  # trick to get # of cols: find position of blank cell below "FECHA"
  res_n_cols = match("", results_cells) - 1L

  # convert to dataframe
  res_df = as.data.frame.matrix(
    x                = matrix(data = results_cells[(2L * res_n_cols + 1L):length(results_cells)],
                              ncol = res_n_cols),
    stringsAsFactors = FALSE
  )
  names(res_df) = results_cells[1L:res_n_cols]
  attr(res_df, "data_types") = results_cells[(res_n_cols+2L):(2L*res_n_cols)]

  # format data
  res_df$FECHA = as.Date.character(res_df$FECHA, format = "%d-%m-%Y")
  # convert data to doubles. warnings are due to missing data points
  res_df[, -1] = suppressWarnings({apply(res_df[, -1], 2, as.double)})

  return(res_df)

}
